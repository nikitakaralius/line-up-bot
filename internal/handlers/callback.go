package handlers

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/nikitkaralius/lineup/internal/polls"
	"github.com/nikitkaralius/lineup/internal/voters"
)

// PollCreationState represents the current state of poll creation
type PollCreationState struct {
	Step      string // "topic", "duration", "confirm"
	Topic     string
	Duration  time.Duration
	MessageID int // ID of the initial poll creation message to delete after topic input
}

// In-memory storage for poll creation states (in production, consider using Redis or database)
var pollCreationStates = make(map[string]*PollCreationState)

func HandleCallback(
	ctx context.Context,
	bot *tgbotapi.BotAPI,
	pollsRepo *polls.Repository,
	votersRepo *voters.Repository,
	callback *tgbotapi.CallbackQuery,
	botUsername string,
	pollsService polls.Service,
) {
	if callback == nil || callback.Data == "" {
		return
	}

	data := callback.Data
	chatID := callback.Message.Chat.ID
	messageID := callback.Message.MessageID
	userID := callback.From.ID

	// Answer callback to remove loading state
	answerCallback := tgbotapi.NewCallback(callback.ID, "")
	bot.Request(answerCallback)

	switch {
	case data == "create_poll":
		handleStartPollCreation(ctx, bot, chatID, messageID, userID)
	case strings.HasPrefix(data, "poll_topic:"):
		handleTopicSelection(ctx, bot, chatID, messageID, userID, data)
	case strings.HasPrefix(data, "poll_duration:"):
		handleDurationSelection(ctx, bot, pollsRepo, chatID, messageID, userID, data, pollsService)
	case data == "poll_duration_custom":
		handleCustomDurationInput(ctx, bot, chatID, messageID, userID)
	case data == "poll_confirm":
		handleConfirmPoll(ctx, bot, pollsRepo, chatID, messageID, userID, pollsService)
	case data == "poll_back":
		handleBackToPollCreation(ctx, bot, chatID, messageID, userID)
	case data == "poll_back_to_duration":
		handleBackToDurationSelection(ctx, bot, chatID, messageID, userID)
	case data == "poll_cancel":
		handleCancelPollCreation(ctx, bot, chatID, messageID, userID)
	case strings.HasPrefix(data, "queue_exit:"):
		handleQueueExit(ctx, bot, pollsRepo, votersRepo, callback, data)
	case strings.HasPrefix(data, "queue_join:"):
		handleQueueJoin(ctx, bot, pollsRepo, votersRepo, callback, data)
	default:
		log.Printf("Unknown callback data: %s", data)
	}
}

func handleStartPollCreation(ctx context.Context, bot *tgbotapi.BotAPI, chatID int64, messageID int, userID int64) {
	stateKey := fmt.Sprintf("%d_%d", chatID, userID)
	pollCreationStates[stateKey] = &PollCreationState{Step: "topic"}

	text := "üìù *–°–æ–∑–¥–∞–Ω–∏–µ –æ–ø—Ä–æ—Å–∞*\n\n–í–≤–µ–¥–∏—Ç–µ —Ç–µ–º—É –æ–ø—Ä–æ—Å–∞:"
	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("‚ùå –û—Ç–º–µ–Ω–∞", "poll_cancel"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ParseMode = "Markdown"
	edit.ReplyMarkup = &keyboard
	bot.Send(edit)
}

func handleTopicSelection(ctx context.Context, bot *tgbotapi.BotAPI, chatID int64, messageID int, userID int64, data string) {
	stateKey := fmt.Sprintf("%d_%d", chatID, userID)
	state, exists := pollCreationStates[stateKey]
	if !exists || state.Step != "topic" {
		return
	}

	// Extract topic from callback data
	parts := strings.Split(data, ":")
	if len(parts) != 2 {
		return
	}

	topic := parts[1]
	state.Topic = topic
	state.Step = "duration"

	// Update the message to show selected topic and remove cancel button
	updatedText := fmt.Sprintf("üìù *–°–æ–∑–¥–∞–Ω–∏–µ –æ–ø—Ä–æ—Å–∞*\n\n‚úÖ **–¢–µ–º–∞:** %s", topic)
	edit := tgbotapi.NewEditMessageText(chatID, messageID, updatedText)
	edit.ParseMode = "Markdown"
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{}}
	bot.Send(edit)

	// Show duration selection
	showDurationSelection(ctx, bot, chatID, messageID, userID, topic)
}

func handleDurationSelection(ctx context.Context, bot *tgbotapi.BotAPI, pollsRepo *polls.Repository, chatID int64, messageID int, userID int64, data string, pollsService polls.Service) {
	stateKey := fmt.Sprintf("%d_%d", chatID, userID)
	state, exists := pollCreationStates[stateKey]
	if !exists || state.Step != "duration" {
		return
	}

	// Extract duration from callback data
	parts := strings.Split(data, ":")
	if len(parts) != 2 {
		return
	}

	durationStr := parts[1]
	duration, err := time.ParseDuration(durationStr)
	if err != nil {
		log.Printf("Invalid duration format: %s", durationStr)
		return
	}

	state.Duration = duration
	state.Step = "confirm"

	// Show confirmation
	text := fmt.Sprintf("‚úÖ *–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ–ø—Ä–æ—Å–∞*\n\nüìã **–¢–µ–º–∞:** %s\n‚è∞ **–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:** %s\n\n–í—Å—ë –ø—Ä–∞–≤–∏–ª—å–Ω–æ?",
		state.Topic, formatDuration(duration))

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("‚úÖ –°–æ–∑–¥–∞—Ç—å", "poll_confirm"),
			tgbotapi.NewInlineKeyboardButtonData("üîô –ù–∞–∑–∞–¥", "poll_back"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("‚ùå –û—Ç–º–µ–Ω–∞", "poll_cancel"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ParseMode = "Markdown"
	edit.ReplyMarkup = &keyboard
	bot.Send(edit)
}

func handleConfirmPoll(ctx context.Context, bot *tgbotapi.BotAPI, pollsRepo *polls.Repository, chatID int64, messageID int, userID int64, pollsService polls.Service) {
	stateKey := fmt.Sprintf("%d_%d", chatID, userID)
	state, exists := pollCreationStates[stateKey]
	if !exists || state.Step != "confirm" {
		return
	}

	// Create enhanced poll question with duration and end time
	endTime := time.Now().UTC().Add(state.Duration)
	pollQuestion := fmt.Sprintf("üìã –¢–µ–º–∞: %s\n‚è∞ –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: %s\nüïê –ó–∞–≤–µ—Ä—à–∏—Ç—Å—è: %s",
		state.Topic,
		formatDuration(state.Duration),
		formatTimeInMSK(endTime))

	// Create poll with Russian options
	pollCfg := tgbotapi.NewPoll(chatID, pollQuestion, []string{"–ò–¥—É", "–ù–µ –∏–¥—É"}...)
	pollCfg.IsAnonymous = false
	pollCfg.AllowsMultipleAnswers = false
	sent, err := bot.Send(pollCfg)
	if err != nil {
		log.Printf("send poll error: %v", err)
		// Show error message
		text := "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ–ø—Ä–æ—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
		edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
		edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{}}
		bot.Send(edit)
		delete(pollCreationStates, stateKey)
		return
	}
	if sent.Poll == nil {
		log.Printf("poll send returned no poll")
		return
	}

	// Store poll in database
	p := &polls.TelegramPollDTO{
		PollID:          sent.Poll.ID,
		ChatID:          chatID,
		MessageID:       sent.MessageID,
		Topic:           state.Topic,
		CreatorID:       userID,
		CreatorUsername: "", // Will be filled from callback.From if available
		CreatorName:     "", // Will be filled from callback.From if available
		StartedAt:       time.Now().UTC(),
		Duration:        state.Duration,
		EndsAt:          time.Now().UTC().Add(state.Duration),
	}

	if err := pollsRepo.InsertPoll(ctx, p); err != nil {
		log.Printf("insert poll error: %v", err)
	}

	// Schedule poll completion job
	if pollsService != nil {
		args := polls.FinishPollArgs{PollID: p.PollID, ChatID: p.ChatID, MessageID: p.MessageID, Topic: p.Topic}
		if err := pollsService.SchedulePollFinish(ctx, args, p.EndsAt); err != nil {
			log.Printf("enqueue finish poll error: %v", err)
		}
	}

	// Update the creation message to show completion
	completionText := "‚úÖ *–û–ø—Ä–æ—Å —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω!*"
	edit := tgbotapi.NewEditMessageText(chatID, messageID, completionText)
	edit.ParseMode = "Markdown"
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{}}
	bot.Send(edit)

	// Clean up state
	delete(pollCreationStates, stateKey)
}

func handleBackToPollCreation(ctx context.Context, bot *tgbotapi.BotAPI, chatID int64, messageID int, userID int64) {
	stateKey := fmt.Sprintf("%d_%d", chatID, userID)
	state, exists := pollCreationStates[stateKey]
	if !exists {
		return
	}

	if state.Step == "confirm" {
		// Go back to duration selection
		state.Step = "duration"
		showDurationSelection(ctx, bot, chatID, messageID, userID, state.Topic)
	}
}

func handleBackToDurationSelection(ctx context.Context, bot *tgbotapi.BotAPI, chatID int64, messageID int, userID int64) {
	stateKey := fmt.Sprintf("%d_%d", chatID, userID)
	state, exists := pollCreationStates[stateKey]
	if !exists || state.Step != "duration_custom" {
		return
	}

	// Go back to duration selection
	state.Step = "duration"
	showDurationSelection(ctx, bot, chatID, messageID, userID, state.Topic)
}

func handleCancelPollCreation(ctx context.Context, bot *tgbotapi.BotAPI, chatID int64, messageID int, userID int64) {
	stateKey := fmt.Sprintf("%d_%d", chatID, userID)
	delete(pollCreationStates, stateKey)

	text := "‚ùå –°–æ–∑–¥–∞–Ω–∏–µ –æ–ø—Ä–æ—Å–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ."
	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ReplyMarkup = &tgbotapi.InlineKeyboardMarkup{InlineKeyboard: [][]tgbotapi.InlineKeyboardButton{}}
	bot.Send(edit)
}

func handleCustomDurationInput(ctx context.Context, bot *tgbotapi.BotAPI, chatID int64, messageID int, userID int64) {
	stateKey := fmt.Sprintf("%d_%d", chatID, userID)
	state, exists := pollCreationStates[stateKey]
	if !exists || state.Step != "duration" {
		return
	}

	// Update state to custom duration input
	state.Step = "duration_custom"

	// Show custom duration input prompt
	text := fmt.Sprintf("‚úèÔ∏è *–í–≤–æ–¥ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏*\n\nüìã **–¢–µ–º–∞:** %s\n\n–í–≤–µ–¥–∏—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n‚Ä¢ `30m` - –º–∏–Ω—É—Ç—ã\n‚Ä¢ `2h` - —á–∞—Å—ã\n‚Ä¢ `1h30m` - –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç\n‚Ä¢ `24h` - —Å—É—Ç–∫–∏\n\n–ü—Ä–∏–º–µ—Ä: `45m`, `2h30m`, `6h`", state.Topic)

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üîô –ù–∞–∑–∞–¥", "poll_back_to_duration"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("‚ùå –û—Ç–º–µ–Ω–∞", "poll_cancel"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ParseMode = "Markdown"
	edit.ReplyMarkup = &keyboard
	bot.Send(edit)
}

func showDurationSelection(ctx context.Context, bot *tgbotapi.BotAPI, chatID int64, messageID int, userID int64, topic string) {
	text := fmt.Sprintf("‚è∞ *–í—ã–±–æ—Ä –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –æ–ø—Ä–æ—Å–∞*\n\nüìã **–¢–µ–º–∞:** %s\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é:", topic)

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("‚è± 15 –º–∏–Ω—É—Ç", "poll_duration:15m"),
			tgbotapi.NewInlineKeyboardButtonData("‚è∞ 30 –º–∏–Ω—É—Ç", "poll_duration:30m"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üïê 1 —á–∞—Å", "poll_duration:1h"),
			tgbotapi.NewInlineKeyboardButtonData("üïï 2 —á–∞—Å–∞", "poll_duration:2h"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üïò 4 —á–∞—Å–∞", "poll_duration:4h"),
			tgbotapi.NewInlineKeyboardButtonData("üåÖ 12 —á–∞—Å–æ–≤", "poll_duration:12h"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üìÖ 1 –¥–µ–Ω—å", "poll_duration:24h"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("‚úèÔ∏è –°–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ", "poll_duration_custom"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("‚ùå –û—Ç–º–µ–Ω–∞", "poll_cancel"),
		),
	)

	edit := tgbotapi.NewEditMessageText(chatID, messageID, text)
	edit.ParseMode = "Markdown"
	edit.ReplyMarkup = &keyboard
	bot.Send(edit)
}

func handleQueueExit(ctx context.Context, bot *tgbotapi.BotAPI, pollsRepo *polls.Repository, votersRepo *voters.Repository, callback *tgbotapi.CallbackQuery, data string) {
	// Extract poll_id from callback data
	parts := strings.Split(data, ":")
	if len(parts) != 2 {
		return
	}
	pollID := parts[1]

	// Remove user from queue by updating their vote to "not coming" (option 1)
	err := votersRepo.UpsertVote(ctx, pollID, *callback.From, []int{1})
	if err != nil {
		log.Printf("Error removing user from queue: %v", err)
		return
	}

	// Update the results message
	updateQueueMessage(ctx, bot, pollsRepo, votersRepo, callback.Message, pollID)

	// Send confirmation
	confirmText := "üö™ –í—ã –≤—ã—à–ª–∏ –∏–∑ –æ—á–µ—Ä–µ–¥–∏"
	answerCallback := tgbotapi.NewCallback(callback.ID, confirmText)
	bot.Request(answerCallback)
}

func handleQueueJoin(ctx context.Context, bot *tgbotapi.BotAPI, pollsRepo *polls.Repository, votersRepo *voters.Repository, callback *tgbotapi.CallbackQuery, data string) {
	// Extract poll_id from callback data
	parts := strings.Split(data, ":")
	if len(parts) != 2 {
		return
	}
	pollID := parts[1]

	// Add user to queue by updating their vote to "coming" (option 0)
	err := votersRepo.UpsertVote(ctx, pollID, *callback.From, []int{0})
	if err != nil {
		log.Printf("Error adding user to queue: %v", err)
		return
	}

	// Update the results message
	updateQueueMessage(ctx, bot, pollsRepo, votersRepo, callback.Message, pollID)

	// Send confirmation
	confirmText := "üôã –í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –æ—á–µ—Ä–µ–¥–∏"
	answerCallback := tgbotapi.NewCallback(callback.ID, confirmText)
	bot.Request(answerCallback)
}

func updateQueueMessage(ctx context.Context, bot *tgbotapi.BotAPI, pollsRepo *polls.Repository, votersRepo *voters.Repository, message *tgbotapi.Message, pollID string) {
	// Get current voters
	voters, err := votersRepo.GetComingVoters(ctx, pollID)
	if err != nil {
		log.Printf("Error getting voters: %v", err)
		return
	}

	// Get poll topic
	topic, err := pollsRepo.GetPollTopic(ctx, pollID)
	if err != nil {
		log.Printf("Error getting poll topic: %v", err)
		topic = "–û–ø—Ä–æ—Å" // fallback
	}

	// Format updated results
	text := formatQueueResults(topic, voters)

	// Create inline keyboard for queue management
	keyboard := createQueueKeyboard(pollID)

	edit := tgbotapi.NewEditMessageText(message.Chat.ID, message.MessageID, text)
	edit.ParseMode = "Markdown"
	edit.ReplyMarkup = &keyboard
	bot.Send(edit)
}

func createQueueKeyboard(pollID string) tgbotapi.InlineKeyboardMarkup {
	return tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("üôã –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è", fmt.Sprintf("queue_join:%s", pollID)),
			tgbotapi.NewInlineKeyboardButtonData("üö™ –í—ã–π—Ç–∏ –∏–∑ –æ—á–µ—Ä–µ–¥–∏", fmt.Sprintf("queue_exit:%s", pollID)),
		),
	)
}

func formatQueueResults(topic string, voters []voters.TelegramVoterDTO) string {
	var sb strings.Builder
	sb.WriteString("üéØ *–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ–ø—Ä–æ—Å–∞:* ")
	sb.WriteString(topic)
	sb.WriteString("\n\n")

	if len(voters) == 0 {
		sb.WriteString("üòî –ù–∏–∫—Ç–æ –Ω–µ –∏–¥–µ—Ç")
		return sb.String()
	}

	sb.WriteString(fmt.Sprintf("üë• *–£—á–∞—Å—Ç–Ω–∏–∫–æ–≤:* %d\n\n", len(voters)))

	for i, voter := range voters {
		sb.WriteString(fmt.Sprintf("%d. ", i+1))
		if voter.Username != "" {
			sb.WriteString("@")
			sb.WriteString(voter.Username)
			if voter.Name != "" {
				sb.WriteString(" (")
				sb.WriteString(voter.Name)
				sb.WriteString(")")
			}
		} else if voter.Name != "" {
			sb.WriteString(voter.Name)
		} else {
			sb.WriteString("–ê–Ω–æ–Ω–∏–º")
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

func formatDuration(d time.Duration) string {
	hours := int(d.Hours())
	minutes := int(d.Minutes()) % 60

	if hours > 0 && minutes > 0 {
		return fmt.Sprintf("%d —á. %d –º–∏–Ω.", hours, minutes)
	} else if hours > 0 {
		return fmt.Sprintf("%d —á.", hours)
	} else {
		return fmt.Sprintf("%d –º–∏–Ω.", minutes)
	}
}
